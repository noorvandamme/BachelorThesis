<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IR Sensor Web Serial</title>
  <!-- Voeg de Lottie-web library toe -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.7.10/lottie.min.js"></script>
  <link rel="stylesheet" href="css/style.css">
</head>

<body>
  <div id="app">
    <div id="not-supported">
      Web Serial is not supported in this browser.
    </div>
    <div id="supported">
      <div id="not-connected">
        <button id="connectButton">Connect</button>
      </div>
      <div id="connected" style="display: none;">
        <div>Connected</div>
        <div id="start-screen">
          <h1>Kies je vijand</h1>
          <button id="character1Button">Character 1</button>
          <button id="character2Button">Character 2</button>
        </div>

        <div id="game-screen" style="display: none;">
          <div id="timer-container">
            <p id="timerDisplay">Time left: 1min</p>
          </div>
          <div id="points-container">
            <p id="pointsDisplay">Points: 10</p>
            <progress id="pointsProgress" value="10" max="10"></progress> <!-- Progress bar -->
          </div>
          <div id="levelDisplay">Level: 1</div>
          <div id="gameOver" style="display: none;">
            <h2>Game Over!</h2>
          </div>
          <!-- Container voor de Lottie animatie -->
          <div id="slot1-container" style="display: none; width: 400px; height: 400px;"></div>
          <div id="slot2-container" style="display: none; width: 400px; height: 400px;"></div>
          <div id="slot3-container" style="display: none; width: 400px; height: 400px;"></div>
          <div id="slot4-container" style="display: none; width: 400px; height: 400px;"></div>
        </div>
      </div>
    </div>
  </div>
  <script type="module">

    // App state
    const hasWebSerial = "serial" in navigator;
    let isConnected = false;

    const gameState = {
      level: 1,               // Huidig niveau
      points: 0,              // Huidige punten
      timeLeft: 10,           // Tijd over in seconden
      timerActive: false,     // Is de timer actief?
      currentLevelIndex: 0    // Index van het huidige level in een array van levels
    };

    const levels = [
      { level: 1, points: 10 },
      { level: 2, points: 20 },
      { level: 3, points: 30 },
      { level: 4, points: 0 }
    ];

    let timerInterval;

    const $notSupported = document.getElementById("not-supported");
    const $supported = document.getElementById("supported");
    const $notConnected = document.getElementById("not-connected");
    const $connected = document.getElementById("connected");

    const $connectButton = document.getElementById("connectButton");
    const $irSensorState = document.getElementById("irSensorState");

    const arduinoInfo = {
      usbProductId: 32823,
      usbVendorId: 9025
    };
    let connectedArduinoPorts = [];

    const init = async () => {
      displaySupportedState();
      if (!hasWebSerial) return;
      displayConnectionState();
      navigator.serial.addEventListener('connect', (e) => {
        const port = e.target;
        const info = port.getInfo();
        console.log('connect', port, info);
        if (isArduinoPort(port)) {
          connectedArduinoPorts.push(port);
          if (!isConnected) {
            connect(port);
          }
        }
      });

      navigator.serial.addEventListener('disconnect', (e) => {
        const port = e.target;
        const info = port.getInfo();
        console.log('disconnect', port, info);
        connectedArduinoPorts = connectedArduinoPorts.filter(p => p !== port);
      });


      const ports = await navigator.serial.getPorts();
      connectedArduinoPorts = ports.filter(isArduinoPort);

      console.log('Ports');
      ports.forEach(port => {
        const info = port.getInfo();
        console.log(info);
      });
      console.log('Connected Arduino ports');
      connectedArduinoPorts.forEach(port => {
        const info = port.getInfo();
        console.log(info);
      });

      if (connectedArduinoPorts.length > 0) {
        connect(connectedArduinoPorts[0]);
      }

      $connectButton.addEventListener("click", handleClickConnect);
    };

    const isArduinoPort = (port) => {
      const info = port.getInfo();
      return info.usbProductId === arduinoInfo.usbProductId && info.usbVendorId === arduinoInfo.usbVendorId;
    };

    const handleClickConnect = async () => {
      const port = await navigator.serial.requestPort();
      console.log(port);
      const info = port.getInfo();
      console.log(info);
      await connect(port);
    };

    const connect = async (port) => {
      isConnected = true;
      displayConnectionState();

      await port.open({ baudRate: 9600 });

      while (port.readable) {
        const decoder = new TextDecoderStream();

        const lineBreakTransformer = new TransformStream({
          transform(chunk, controller) {
            const text = chunk;
            const lines = text.split("\n");
            lines[0] = (this.remainder || "") + lines[0];
            this.remainder = lines.pop();
            lines.forEach((line) => controller.enqueue(line));
          },
          flush(controller) {
            if (this.remainder) {
              controller.enqueue(this.remainder);
            }
          },
        });

        const readableStreamClosed = port.readable.pipeTo(decoder.writable);
        const inputStream = decoder.readable.pipeThrough(lineBreakTransformer);
        const reader = inputStream.getReader();

        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }
            if (value) {
              processSensorState(value.trim());
            }
          }
        } catch (error) {
          console.error("Error reading from port", error);
        } finally {
          reader.releaseLock();
        }
      }
    };


    let currentState = "unbroken"; //current sensor state 

    const processSensorState = (state) => {
      //console.log(`Raw state: ${state}`);

      //geen weizigingen meer aanbrengen wnr spel gedaan is
      if (gameState.level === 4) return;

      let slot1 = lottie.loadAnimation({
        container: document.getElementById('slot1-container'),// container waar animatie komt 
        renderer: 'svg',
        loop: false,
        autoplay: false,
        path: 'https://lottie.host/e63bd355-77f6-4d02-bf33-7642c530cdea/9NZV1bWT8m.json'
      });

      let slot2 = lottie.loadAnimation({
        container: document.getElementById('slot2-container'),// container waar animatie komt 
        renderer: 'svg',
        loop: false,
        autoplay: false,
        path: 'https://lottie.host/171f709d-8f30-4ee1-904a-c1b8b5e8e3e2/xXwExlc1Wh.json'
      });

      let slot3 = lottie.loadAnimation({
        container: document.getElementById('slot3-container'),// container waar animatie komt 
        renderer: 'svg',
        loop: false,
        autoplay: false,
        path: 'https://lottie.host/0f5c4ecc-bc27-4b5d-8145-8f35bb3562f8/GNAoEGpLFn.json'
      });

      let slot4 = lottie.loadAnimation({
        container: document.getElementById('slot4-container'),// container waar animatie komt 
        renderer: 'svg',
        loop: false,
        autoplay: false,
        path: 'https://lottie.host/236d3a25-87cc-43e2-8ccd-7f037c937820/KGclGJjM7B.json'
      });

      try {
        // Parse de JSON-string die we van de Arduino krijgen
        const data = JSON.parse(state);
        //console.log("Parsed data:", data);
        //console.log(data.sensor)
        //console.log(data.state)

        // if (data.sensor === 0) {
        //   console.log('OK')
        // }

        // if (data.state === "Broken") {
        //   console.log('state Ok')
        // }

        let sensor = data.sensor;
        let sensorState = data.state;

        if (sensorState === "Broken") {
          console.log("broken")
          currentState = "broken";
        } else if (sensorState === "Unbroken") {
          // => betekent dat state van broken naar unbroken is gegaan 
          if (currentState === "broken") {
            switch (sensor) {
              case 0:

                //if (state === "Broken") {
                //console.log("Effect triggered for Sensor 0: Broken");

                //ANIMATION 
                if (slot1) slot1.destroy();

                const slot1Container = document.getElementById('slot1-container');
                slot1Container.style.display = 'block';

                //herinitialiseer de animatie zodat elke keer opnieuw begint 
                slot1 = lottie.loadAnimation({
                  container: document.getElementById('slot1-container'),
                  renderer: 'svg',
                  loop: false,
                  autoplay: true,
                  path: 'https://lottie.host/e63bd355-77f6-4d02-bf33-7642c530cdea/9NZV1bWT8m.json'
                });

                //POINTS
                gameState.points -= 20;
                //console.log("Points remaining: " + points);
                //updatePointsDisplay();
                //}
                break;

              case 1:
                //if (state === "Broken") {
                //console.log("Effect triggered for Sensor 1: Broken");
                if (slot2) slot2.destroy();

                const slot2Container = document.getElementById('slot2-container');
                slot2Container.style.display = 'block';

                //herinitialiseer de animatie zodat elke keer opnieuw begint 
                slot2 = lottie.loadAnimation({
                  container: document.getElementById('slot2-container'),
                  renderer: 'svg',
                  loop: false,
                  autoplay: true,
                  path: 'https://lottie.host/171f709d-8f30-4ee1-904a-c1b8b5e8e3e2/xXwExlc1Wh.json'
                });

                //POINTS
                gameState.points -= 30;
                //console.log("Points remaining: " + points);
                //updatePointsDisplay();
                //}
                break;

              case 2:
                //if (state === "Broken") {
                //console.log("Effect triggered for Sensor 2: Broken");
                if (slot3) slot3.destroy();

                const slot3Container = document.getElementById('slot3-container');
                slot3Container.style.display = 'block';

                //herinitialiseer de animatie zodat elke keer opnieuw begint 
                slot3 = lottie.loadAnimation({
                  container: document.getElementById('slot3-container'),
                  renderer: 'svg',
                  loop: false,
                  autoplay: true,
                  path: 'https://lottie.host/0f5c4ecc-bc27-4b5d-8145-8f35bb3562f8/GNAoEGpLFn.json'
                });

                //POINTS
                gameState.points -= 40;
                //console.log("Points remaining: " + points);
                //updatePointsDisplay();
                //}
                break;

              case 3:
                //if (state === "Broken") {
                //console.log("Effect triggered for Sensor 3: Broken");
                if (slot4) slot4.destroy();

                const slot4Container = document.getElementById('slot4-container');
                slot4Container.style.display = 'block';

                //herinitialiseer de animatie zodat elke keer opnieuw begint 
                slot4 = lottie.loadAnimation({
                  container: document.getElementById('slot4-container'),
                  renderer: 'svg',
                  loop: false,
                  autoplay: true,
                  path: 'https://lottie.host/236d3a25-87cc-43e2-8ccd-7f037c937820/KGclGJjM7B.json'
                });

                //POINTS
                gameState.points -= 10;
                //console.log("Points remaining: " + points);
                //}
                break;
            }
          }
        }

        updatePointsDisplay();

      } catch (error) {
        console.error("Failed to parse JSON:", error);  // Foutmelding als JSON niet goed kan worden geparsed
      }
    };

    const startGame = () => {
      document.getElementById("start-screen").style.display = "none"; // Verberg het startscherm
      document.getElementById("game-screen").style.display = "block"; // Toon het game-scherm

      gameState.level = 1; // starten met level 1 
      gameState.points = levels[0].points;
      gameState.timeLeft = 60;
      gameState.currentLevelIndex = 0;

      updatePointsDisplay();

      startTimer();
    }

    const startTimer = () => {
      if (gameState.timerActive) return; //voorkomen dat de timer meerdere keren start 
      gameState.timerActive = true;

      timerInterval = setInterval(() => {
        if (gameState.timeLeft > 0) {//als er tijd over is 
          gameState.timeLeft--;
          document.getElementById("timerDisplay").textContent = `Time left: ${gameState.timeLeft}s`;
        } else {//geen tijd meer over 
          clearInterval(timerInterval); //stop timer
          gameState.timerActive = false;
          handleGameOver(); //gameover 
        }
      }, 1000); // update seconden 
    }

    const resetTimer = () => {
      gameState.timeLeft = 60;
      gameState.timerActive = false;
      document.getElementById("timerDisplay").textContent = `Time Left: ${gameState.timeLeft}s`;
    }

    const handleGameOver = () => {
      //level instellen op level 4 
      gameState.level = 4;
      updatePointsDisplay();//update pointsdisplay naar game over 
      clearInterval(gameState.timerInterval); // stop timer 
      document.getElementById("gameOver").style.display = "block";

      setTimeout(() => {
        resetGame();
      }, 5000);
    };

    //reset spel voor nieuwe speler
    const resetGame = () => {
      gameState.level = 1;
      gameState.points = levels[0].points;
      gameState.timeLeft = 10;
      gameState.timerActive = false;
      gameState.currentLevelIndex = 0;

      updatePointsDisplay();
      document.getElementById("gameOver").style.display = "none";
      document.getElementById("game-screen").style.display = "none";
      document.getElementById("start-screen").style.display = "block";

      document.getElementById("timerDisplay").textContent = `Time left: ${gameState.timeLeft}s`;
      document.getElementById("pointsDisplay").textContent = `Points: ${gameState.points}`;
      document.getElementById("pointsProgress").value = gameState.points;
      document.getElementById("levelDisplay").textContent = `Level: ${gameState.level}`;
    };

    const oldUpdatePointsDisplay = () => {
      const pointsDisplay = document.getElementById("pointsDisplay");
      const pointsProgress = document.getElementById("pointsProgress");
      document.getElementById("levelDisplay").textContent = `Level: ${gameState.level}`;

      //points kunnen niet negatief worden 
      gameState.points = Math.max(gameState.points, 0);

      const maxPoints = levels[gameState.currentLevelIndex].points;  //max punten voor huidige level instellen 
      pointsProgress.max = maxPoints;

      const progressValue = Math.max(gameState.points);  //value is resterende leven 
      pointsProgress.value = progressValue;

      if (gameState.points <= 0 && gameState.currentLevelIndex < levels.length - 1) {
        //3 seconden wachten vooraleer naar next level zodat UI kan updaten 
        setTimeout(() => {
          nextLevel();
        }, 3000);
      } else if (gameState.currentLevelIndex === levels.length - 1) {
        pointsDisplay.textContent = "Winnaar";
        clearInterval(timerInterval); //timer stoppen 
        gameState.timerActive = false;

        setTimeout(() => {
          resetGame();
        }, 5000);
        return;

      } else {
        pointsDisplay.textContent = `Points: ${gameState.points}`;
      }

      if (gameState.points <= 0 && gameState.currentLevelIndex < levels.length - 1) {
        nextLevel(); //schakel naar volgende level wnr er 0 of minder punten zijn en gebasseerd op current level
      }

      console.log("Max Points:", maxPoints, "Current Points:", gameState.points, "Progress Value:", progressValue);
    };

    const updatePointsDisplay = () => {
      const pointsDisplay = document.getElementById("pointsDisplay");
      const pointsProgress = document.getElementById("pointsProgress");
      document.getElementById("levelDisplay").textContent = `Level: ${gameState.level}`;

      gameState.points = Math.max(gameState.points, 0); 
      const maxPoints = levels[gameState.currentLevelIndex].points; 
      pointsProgress.max = maxPoints;

      pointsProgress.value = gameState.points; 
      pointsDisplay.textContent = `Points: ${gameState.points}`;

      
      if (gameState.points <= 0 && gameState.currentLevelIndex < levels.length - 1) {
        // 3 seconden wachten vooraleer naar next level zodat UI kan updaten 
        setTimeout(() => {
          nextLevel();
        }, 3000); 
      } else if (gameState.currentLevelIndex === levels.length - 1) {
        pointsDisplay.textContent = "Winnaar";
        clearInterval(timerInterval);
        gameState.timerActive = false;
        setTimeout(() => {
          resetGame();
        }, 5000);
      }
    };


    const nextLevel = () => {
      if (gameState.currentLevelIndex < levels.length - 1) {
        gameState.currentLevelIndex++;
        gameState.level++;
        gameState.points = levels[gameState.currentLevelIndex].points;
        //resetTimer(); -> OPTIE 
        updatePointsDisplay();
      } else {
        console.log("Winnaar");
      }
    }

    //EVENTLISTENER VIJAND KEUZE 
    document.getElementById("character1Button").addEventListener("click", () => {
      startGame();
    });

    document.getElementById("character2Button").addEventListener("click", () => {
      startGame();
    });


    const displaySupportedState = () => {
      if (hasWebSerial) {
        $notSupported.style.display = "none";
        $supported.style.display = "block";
      } else {
        $notSupported.style.display = "block";
        $supported.style.display = "none";
      }
    };

    const displayConnectionState = () => {
      if (isConnected) {
        $notConnected.style.display = "none";
        $connected.style.display = "block";
      } else {
        $notConnected.style.display = "block";
        $connected.style.display = "none";
      }
    };

    init();

  </script>
</body>

</html>